<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FactoryioConnector" Id="{307071d9-10a8-4b21-8178-651653349033}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM FactoryioConnector
VAR
    // IP address of factoryio modbus TCP/IP server
    sFactoryIPAddr: STRING := '127.0.0.1';
    // Port number of factoryio modbus TCP/IP server
    nFactoryTCPPort: UINT := 5502;
    // Modbus slave ID of factoryio modbus TCP/IP server
    nFactoryUnitID: BYTE := 1;
    // Timeout that may not be exceeded by execution of the ADS command
    tConnectionTimeout: TIME := T#2S;

    // Modbus connection to read digital sensors
    fbReadInputs: FB_MBReadInputs;
    // Modbus connection to read analog sensors
    fbReadInputRegs: FB_MBReadInputRegs;
    // Modbus connection to control digital actuators
    fbWriteCoils: FB_MBWriteCoils;
    // Modbus connection to control analog actuators
    fbWriteRegs: FB_MBWriteRegs;

    // Factoryio digital input mapping
    stFactoryioDigitalInputs: ST_ModbusMapInputs;
    // Factoryio analog input mapping
    stFactoryioAnalogInputs: ST_ModbusMapInputRegs;
    // Factoryio digital output mapping
    stFactoryioDigitalOutputs: ST_ModbusMapCoils;
    // Factoryio analog output mapping
    stFactoryioAnalogOutputs: ST_ModbusMapHoldingRegs;

    // Factory Inputs
    stInputs AT %Q*: ST_FactoryInputs;
    // Factory Outputs
    stOutputs AT %I*: ST_FactoryOutputs;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Read digital sensors
fbReadInputs(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 24,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioDigitalInputs),
    pDestAddr := ADR(stFactoryioDigitalInputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign digital sensors to inputs
    stInputs.bBtnReset := stFactoryioDigitalInputs.bBtnReset;
    stInputs.bBtnStart := stFactoryioDigitalInputs.bBtnStart;
    stInputs.bBtnStopNC := stFactoryioDigitalInputs.bBtnStopNC;
    stInputs.bSwManual := stFactoryioDigitalInputs.bSwManual;
    stInputs.bSwAuto := stFactoryioDigitalInputs.bSwAuto;
    stInputs.bSwEmergStopNC := stFactoryioDigitalInputs.bSwEmergStopNC;
    stInputs.bLbScaleEntry := stFactoryioDigitalInputs.bLbScaleEntry;
    stInputs.bLbScale := stFactoryioDigitalInputs.bLbScale;
    stInputs.bLbScaleExit := stFactoryioDigitalInputs.bLbScaleExit;
    stInputs.bLbConveyorLeftEntry := stFactoryioDigitalInputs.bLbConveyorLeftEntry;
    stInputs.bLbConveyorLeftExit := stFactoryioDigitalInputs.bLbConveyorLeftExit;
    stInputs.bLbConveyorForwardEntry := stFactoryioDigitalInputs.bLbConveyorForwardEntry;
    stInputs.bLbConveyorForwardExit := stFactoryioDigitalInputs.bLbConveyorForwardExit;
    stInputs.bLbConveyorRightEntry := stFactoryioDigitalInputs.bLbConveyorRightEntry;
    stInputs.bLbConveyorRightExit := stFactoryioDigitalInputs.bLbConveyorRightExit;
    stInputs.bSwConveyorFeedOn := stFactoryioDigitalInputs.bSwConveyorFeedOn;
    stInputs.bSwConveyorForwardOn := stFactoryioDigitalInputs.bSwConveyorForwardOn;
    stInputs.bSwConveyorLeftOn := stFactoryioDigitalInputs.bSwConveyorLeftOn;
    stInputs.bSwConveyorRightOn := stFactoryioDigitalInputs.bSwConveyorRightOn;
    stInputs.bSwConveyorScaleOn := stFactoryioDigitalInputs.bSwConveyorScaleOn;
    stInputs.bFactoryRunning := stFactoryioDigitalInputs.bFactoryRunning;
    stInputs.bFactoryPaused := stFactoryioDigitalInputs.bFactoryPaused;
    stInputs.bFactoryReset := stFactoryioDigitalInputs.bFactoryReset;

    // Execute modbus function
    fbReadInputs.bExecute := TRUE;
ELSE
    fbReadInputs.bExecute := FALSE;
END_IF

// Read analog sensors
fbReadInputRegs(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 6,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioAnalogInputs),
    pDestAddr := ADR(stFactoryioAnalogInputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign analog sensors to inputs
    stInputs.fScaleWeight := WORD_TO_REAL(stFactoryioAnalogInputs.fScaleWeight) / 100;
    stInputs.fFactoryTimeScale := WORD_TO_REAL(stFactoryioAnalogInputs.fFactoryTimeScale) / 100;

    // Execute modbus function
    fbReadInputRegs.bExecute := TRUE;
ELSE
    fbReadInputRegs.bExecute := FALSE;
END_IF

// Write digital outputs
fbWriteCoils(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 24,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioDigitalOutputs),
    pSrcAddr := ADR(stFactoryioDigitalOutputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign outputs to digital actuators
    stFactoryioDigitalOutputs.bBtnResetLight := stOutputs.bBtnResetLight;
    stFactoryioDigitalOutputs.bBtnStartLight := stOutputs.bBtnStartLight;
    stFactoryioDigitalOutputs.bBtnStopLight := stOutputs.bBtnStopLight;
    stFactoryioDigitalOutputs.bAlarmSiren := stOutputs.bAlarmSiren;
    stFactoryioDigitalOutputs.bStackLightRed := stOutputs.bStackLightRed;
    stFactoryioDigitalOutputs.bStackLightGreen := stOutputs.bStackLightGreen;
    stFactoryioDigitalOutputs.bStackLightYellow := stOutputs.bStackLightYellow;
    stFactoryioDigitalOutputs.bConveyorFeed := stOutputs.bConveyorFeed;
    stFactoryioDigitalOutputs.bConveyorScale := stOutputs.bConveyorScale;
    stFactoryioDigitalOutputs.bConveyorLeft := stOutputs.bConveyorLeft;
    stFactoryioDigitalOutputs.bConveyorForward := stOutputs.bConveyorForward;
    stFactoryioDigitalOutputs.bConveyorRight := stOutputs.bConveyorRight;
    stFactoryioDigitalOutputs.bSorterLeft := stOutputs.bSorterLeft;
    stFactoryioDigitalOutputs.bSorterRaise := stOutputs.bSorterRaise;
    stFactoryioDigitalOutputs.bSorterRight := stOutputs.bSorterRight;
    stFactoryioDigitalOutputs.bEmitter := stOutputs.bEmitter;

    // Execute modbus function
    fbWriteCoils.bExecute := TRUE;
ELSE
    fbWriteCoils.bExecute := FALSE;
END_IF

// Write analog outputs
fbWriteRegs(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 6,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioAnalogOutputs),
    pSrcAddr := ADR(stFactoryioAnalogOutputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign outputs to analog actuators
    stFactoryioAnalogOutputs.nDispWeight := INT_TO_WORD(stOutputs.nDispWeight);
    stFactoryioAnalogOutputs.nDispCountLeft := INT_TO_WORD(stOutputs.nDispCountLeft);
    stFactoryioAnalogOutputs.nDispCountForward := INT_TO_WORD(stOutputs.nDispCountForward);
    stFactoryioAnalogOutputs.nDispCountRight := INT_TO_WORD(stOutputs.nDispCountRight);
    stFactoryioAnalogOutputs.nFactoryCameraPosition := INT_TO_WORD(stOutputs.nFactoryCameraPosition);

    // Execute modbus function
    fbWriteRegs.bExecute := TRUE;
ELSE
    fbWriteRegs.bExecute := FALSE;
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>