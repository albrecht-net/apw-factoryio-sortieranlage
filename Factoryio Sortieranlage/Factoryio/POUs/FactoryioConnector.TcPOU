<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FactoryioConnector" Id="{307071d9-10a8-4b21-8178-651653349033}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM FactoryioConnector
VAR
    // IP address of factoryio modbus TCP/IP server
    sFactoryIPAddr: STRING := '127.0.0.1';
    // Port number of factoryio modbus TCP/IP server
    nFactoryTCPPort: UINT := 5502;
    // Modbus slave ID of factoryio modbus TCP/IP server
    nFactoryUnitID: BYTE := 1;
    // Timeout that may not be exceeded by execution of the ADS command
    tConnectionTimeout: TIME := T#2S;

    // Modbus connection to read digital sensors
    fbReadInputs: FB_MBReadInputs;
    // Modbus connection to read analog sensors
    fbReadInputRegs: FB_MBReadInputRegs;
    // Modbus connection to control digital actuators
    fbWriteCoils: FB_MBWriteCoils;
    // Modbus connection to control analog actuators
    fbWriteRegs: FB_MBWriteRegs;

    // Factoryio digital input mapping
    stFactoryioDigitalInputs: ST_ModbusMapInputs;
    // Factoryio analog input mapping
    stFactoryioAnalogInputs: ST_ModbusMapInputRegs;
    // Factoryio digital output mapping
    stFactoryioDigitalOutputs: ST_ModbusMapCoils;
    // Factoryio analog output mapping
    stFactoryioAnalogOutputs: ST_ModbusMapHoldingRegs;

    // S0 Reset
    bBtnReset AT %Q*: BOOL;
    // S1 Start
    bBtnStart AT %Q*: BOOL;
    // S2 Stop NC
    bBtnStopNC AT %Q*: BOOL;
    // S3 Manual
    bSwManual AT %Q*: BOOL;
    // S4 Auto
    bSwAuto AT %Q*: BOOL;
    // S5 Emergency stop
    bSwEmergStopNC AT %Q*: BOOL;
    // B10 LB: At scale entry
    bLbScaleEntry AT %Q*: BOOL;
    // B11 LB: At scale
    bLbScale AT %Q*: BOOL;
    // B12 LB: At scale exit
    bLbScaleExit AT %Q*: BOOL;
    // B20 LB: At left entry
    bLbConveyorLeftEntry AT %Q*: BOOL;
    // B21 LB: At exit left
    bLbConveyorLeftExit AT %Q*: BOOL;
    // B30 LB: At forward entry
    bLbConveyorForwardEntry AT %Q*: BOOL;
    // B31 LB: At exit front
    bLbConveyorForwardExit AT %Q*: BOOL;
    // B40 LB: At right entry
    bLbConveyorRightEntry AT %Q*: BOOL;
    // B41 LB: At exit right
    bLbConveyorRightExit AT %Q*: BOOL;
    // S100 Band Einlauf ein
    bSwConveyorFeedOn AT %Q*: BOOL;
    // S101 Band Auslauf ein
    bSwConveyorForwardOn AT %Q*: BOOL;
    // S102 Band Auslauf Links ein
    bSwConveyorLeftOn AT %Q*: BOOL;
    // S103 Band Auslauf Rechts ein
    bSwConveyorRightOn AT %Q*: BOOL;
    // S104 Band Waage ein
    bSwConveyorScaleOn AT %Q*: BOOL;
    // FACTORY I/O (Running)
    bFactoryRunning AT %Q*: BOOL;
    // FACTORY I/O (Paused)
    bFactoryPaused AT %Q*: BOOL;
    // FACTORY I/O (Reset)
    bFactoryReset AT %Q*: BOOL;
    // Gewicht
    fScaleWeight AT %Q*: REAL;
    // FACTORY I/O (Time Scale)
    fFactoryTimeScale AT %Q*: REAL;

    // H0 Reset light
    bBtnResetLight AT %I*: BOOL;
    // H1 Start light
    bBtnStartLight AT %I*: BOOL;
    // H2 Stop light
    bBtnStopLight AT %I*: BOOL;
    // B0 Alarm Siren
    bAlarmSiren AT %I*: BOOL;
    // H20 Signal Light Red
    bStackLightRed AT %I*: BOOL;
    // H21 Signal Light Green
    bStackLightGreen AT %I*: BOOL;
    // H22 Signal Light Yellow
    bStackLightYellow AT %I*: BOOL;
    // M10 Entry conveyor
    bConveyorFeed AT %I*: BOOL;
    // M12 Load scale
    bConveyorScale AT %I*: BOOL;
    // M20 Left conveyor
    bConveyorLeft AT %I*: BOOL;
    // M30 Front conveyor
    bConveyorForward AT %I*: BOOL;
    // M40 Right conveyor
    bConveyorRight AT %I*: BOOL;
    // M50 Send left
    bSorterLeft AT %I*: BOOL;
    // M51 Send forward
    bSorterRaise AT %I*: BOOL;
    // M52 Send right
    bSorterRight AT %I*: BOOL;
    // Emitter
    bEmitter AT %I*: BOOL;
    // Gewicht
    nDispWeight AT %I*: INT;
    // Left count
    nDispCountLeft AT %I*: INT;
    // Forward count
    nDispCountForward AT %I*: INT;
    // Right count
    nDispCountRight AT %I*: INT;
    // FACTORY I/O (Camera Position)
    nFactoryCameraPosition AT %I*: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Read digital sensors
fbReadInputs(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 24,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioDigitalInputs),
    pDestAddr := ADR(stFactoryioDigitalInputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign digital sensors to inputs
    bBtnReset := stFactoryioDigitalInputs.bBtnReset;
    bBtnStart := stFactoryioDigitalInputs.bBtnStart;
    bBtnStopNC := stFactoryioDigitalInputs.bBtnStopNC;
    bSwManual := stFactoryioDigitalInputs.bSwManual;
    bSwAuto := stFactoryioDigitalInputs.bSwAuto;
    bSwEmergStopNC := stFactoryioDigitalInputs.bSwEmergStopNC;
    bLbScaleEntry := stFactoryioDigitalInputs.bLbScaleEntry;
    bLbScale := stFactoryioDigitalInputs.bLbScale;
    bLbScaleExit := stFactoryioDigitalInputs.bLbScaleExit;
    bLbConveyorLeftEntry := stFactoryioDigitalInputs.bLbConveyorLeftEntry;
    bLbConveyorLeftExit := stFactoryioDigitalInputs.bLbConveyorLeftExit;
    bLbConveyorForwardEntry := stFactoryioDigitalInputs.bLbConveyorForwardEntry;
    bLbConveyorForwardExit := stFactoryioDigitalInputs.bLbConveyorForwardExit;
    bLbConveyorRightEntry := stFactoryioDigitalInputs.bLbConveyorRightEntry;
    bLbConveyorRightExit := stFactoryioDigitalInputs.bLbConveyorRightExit;
    bSwConveyorFeedOn := stFactoryioDigitalInputs.bSwConveyorFeedOn;
    bSwConveyorForwardOn := stFactoryioDigitalInputs.bSwConveyorForwardOn;
    bSwConveyorLeftOn := stFactoryioDigitalInputs.bSwConveyorLeftOn;
    bSwConveyorRightOn := stFactoryioDigitalInputs.bSwConveyorRightOn;
    bSwConveyorScaleOn := stFactoryioDigitalInputs.bSwConveyorScaleOn;
    bFactoryRunning := stFactoryioDigitalInputs.bFactoryRunning;
    bFactoryPaused := stFactoryioDigitalInputs.bFactoryPaused;
    bFactoryReset := stFactoryioDigitalInputs.bFactoryReset;

    // Execute modbus function
    fbReadInputs.bExecute := TRUE;
ELSE
    fbReadInputs.bExecute := FALSE;
END_IF

// Read analog sensors
fbReadInputRegs(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 6,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioAnalogInputs),
    pDestAddr := ADR(stFactoryioAnalogInputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign analog sensors to inputs
    fScaleWeight := WORD_TO_REAL(stFactoryioAnalogInputs.fScaleWeight) / 100;
    fFactoryTimeScale := WORD_TO_REAL(stFactoryioAnalogInputs.fFactoryTimeScale) / 100;

    // Execute modbus function
    fbReadInputRegs.bExecute := TRUE;
ELSE
    fbReadInputRegs.bExecute := FALSE;
END_IF

// Write digital outputs
fbWriteCoils(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 24,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioDigitalOutputs),
    pSrcAddr := ADR(stFactoryioDigitalOutputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign outputs to digital actuators
    stFactoryioDigitalOutputs.bBtnResetLight := bBtnResetLight;
    stFactoryioDigitalOutputs.bBtnStartLight := bBtnStartLight;
    stFactoryioDigitalOutputs.bBtnStopLight := bBtnStopLight;
    stFactoryioDigitalOutputs.bAlarmSiren := bAlarmSiren;
    stFactoryioDigitalOutputs.bStackLightRed := bStackLightRed;
    stFactoryioDigitalOutputs.bStackLightGreen := bStackLightGreen;
    stFactoryioDigitalOutputs.bStackLightYellow := bStackLightYellow;
    stFactoryioDigitalOutputs.bConveyorFeed := bConveyorFeed;
    stFactoryioDigitalOutputs.bConveyorScale := bConveyorScale;
    stFactoryioDigitalOutputs.bConveyorLeft := bConveyorLeft;
    stFactoryioDigitalOutputs.bConveyorForward := bConveyorForward;
    stFactoryioDigitalOutputs.bConveyorRight := bConveyorRight;
    stFactoryioDigitalOutputs.bSorterLeft := bSorterLeft;
    stFactoryioDigitalOutputs.bSorterRaise := bSorterRaise;
    stFactoryioDigitalOutputs.bSorterRight := bSorterRight;
    stFactoryioDigitalOutputs.bEmitter := bEmitter;

    // Execute modbus function
    fbWriteCoils.bExecute := TRUE;
ELSE
    fbWriteCoils.bExecute := FALSE;
END_IF

// Write analog outputs
fbWriteRegs(
    sIPAddr := sFactoryIPAddr,
    nTCPPort := nFactoryTCPPort,
    nUnitID := nFactoryUnitID,
    nQuantity := 6,
    nMBAddr := 0,
    cbLength := SIZEOF(stFactoryioAnalogOutputs),
    pSrcAddr := ADR(stFactoryioAnalogOutputs),
    tTimeout := tConnectionTimeout
);

IF NOT fbReadInputs.bBusy THEN
    // Assign outputs to analog actuators
    stFactoryioAnalogOutputs.nDispWeight := INT_TO_WORD(nDispWeight);
    stFactoryioAnalogOutputs.nDispCountLeft := INT_TO_WORD(nDispCountLeft);
    stFactoryioAnalogOutputs.nDispCountForward := INT_TO_WORD(nDispCountForward);
    stFactoryioAnalogOutputs.nDispCountRight := INT_TO_WORD(nDispCountRight);
    stFactoryioAnalogOutputs.nFactoryCameraPosition := INT_TO_WORD(nFactoryCameraPosition);

    // Execute modbus function
    fbWriteRegs.bExecute := TRUE;
ELSE
    fbWriteRegs.bExecute := FALSE;
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>